{% macro mod(p) %}
    {% if p is mapping %}
        {% for k, v in p.items() %}
            {% if k == 'self' %}
                tonic::include_proto!("{{ v }}");
            {% else %}
                pub mod {{ k }} {
                    {{ mod(v) }}
                }
            {% endif %}
        {% endfor %}
    {% else %}
        tonic::include_proto!("{{ p }}");
    {% endif %}
{% endmacro %}

{{ mod(packages) }}

{% macro get_field_value(field_parts) %}
    {% for f in field_parts -%}
        {#- "type" is reserved word in Rust, so need escape -#}
        {#- GoogleAds resource field to proto mapping is sometimes screwy. So map "keyword" to "criterion". -#}
        {{ "r#" if f == "type" }}{{ {"keyword":"criterion"}[f] | default(f) }}{{ ".as_ref().unwrap()." if not loop.last }}{{ "()" if loop.last and ("status" in f or "type" in f or "device" == f) }}
    {%- endfor %}
{% endmacro %}

impl google::ads::googleads::v10::services::GoogleAdsRow {

    /// Returns GoogleAdsRow field value by field name
    ///
    /// # Arguments
    /// * `field_name` - A string slice that holds name of a field in GoogleAdsRow struct
    ///
    /// Support fields:
    /// * all non-list Metrics fields are supported
    /// * all non-list Segment fields are supported
    /// * only basic Attribute fields are supported (eg. id, name, status)
    /// 
    /// # Examples
    ///
    /// ```
    /// let field_mask = response.field_mask.unwrap();
    /// for row in response.results {
    ///     for path in &field_mask.paths {
    ///         print!("{}\t", row.get(&path));
    ///     }
    ///     print!("\n");
    /// }
    /// ```
    pub fn get(&self, field_name: &str) -> String {
        match field_name {
            {% for field_parts in array_field_parts %}
            "{{ '.'.join(field_parts) }}" => format!("{:?}", self.{{ get_field_value(field_parts) }}),
            {%  endfor %}
            _ => "unsupported".to_string()
        }
    }

}


